#include "CommandRunner.hpp"
#include <memory>
#include <stdio.h>
#include <fstream>
#include <sstream>
#include <iostream>

#include <stout/try.hpp>

#define TEMP_FILE_TEMPLATE "/tmp/criteo-mesos-XXXXXX"

namespace criteo {
namespace mesos {
namespace CommandRunner {

/*
 * Represent a temporary file that can be either written or read from.
 */
class TemporaryFile
{
public:
  TemporaryFile() {
    char filepath[] = TEMP_FILE_TEMPLATE;
    if(mkstemp(filepath) == -1)
      throw std::runtime_error(
        "Unable to create temporary file to run commands");
    m_filepath = std::string(filepath);
  }

  /*
   * Read whole content of the temporary file.
   * @return The content of the file.
   */
  std::string readAll() const {
    std::ifstream ifs(m_filepath);
    std::string content((std::istreambuf_iterator<char>(ifs)),
                        (std::istreambuf_iterator<char>()));
    ifs.close();
    return content;
  }

  /*
   * Write content to the temporary file and flush it.
   * @param content The content to write to the file.
   */
  void write(const std::string& content) const {
    std::ofstream ofs;
    ofs.open(m_filepath);
    ofs << content;
    std::flush(ofs);
    ofs.close();
  }

  ~TemporaryFile() {
    if(remove(m_filepath.c_str()) != 0)
      std::cerr << "Error while deleting " << m_filepath << std::endl;
  }

  inline const std::string& filepath() const { return m_filepath; }

private:
  std::string m_filepath;
};

/*
 * Run a command and provide it with two filepath, one containing the
 * input and one to write the output to.
 *
 * @param command The command to run.
 * @param inputFilepath The file path of the file where input is stored.
 * @param outputFilepath The file path of the file where output is stored.
 * @return The standard output of the command.
 */
std::string runCommand(const std::string& command, const std::string& inputFilepath,
                       const std::string& outputFilepath) {
  std::stringstream fullCommand;
  fullCommand << command << " " << inputFilepath << " " << outputFilepath;

  std::array<char, 128> buffer;
  std::string stdoutData;
  std::shared_ptr<FILE> pipe(popen(fullCommand.str().c_str(), "r"), pclose);
  if (!pipe)
    throw std::runtime_error("popen() failed!");

  while (!feof(pipe.get())) {
    if (fgets(buffer.data(), 128, pipe.get()) != nullptr)
      stdoutData += buffer.data();
  }
  return stdoutData;
}

/*
 * Run a command to which we pass input and return an output. To pass
 * input and get output, CommandRunner pass two temporary files to the
 * command arguments, one being the input file the command read its
 * inputs from and one being the output file where the command must send
 * its outputs
 *
 * @param command The command to run.
 * @param input The input to pass to the command.
 * @param output The output generated by the command
 */
std::string run(const std::string& command, const std::string& input) {
  try {
    TemporaryFile inputFile;
    TemporaryFile outputFile;
    inputFile.write(input);
    runCommand(command, inputFile.filepath(), outputFile.filepath());
    return outputFile.readAll();
  }
  catch(const std::runtime_error& e) {
    return std::string();
  }
}

}
}
}
